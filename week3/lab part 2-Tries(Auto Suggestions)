#include "trie.h"
#include <iostream>
using namespace std;

#define ALPHABET_SIZE 26
#define CHAR_TO_INDEX(c) ((int)c - (int)'a')

struct TrieNode{
	bool isWordEnd=false;
	TrieNode* children[26];
};

class Trie{
public:
TrieNode* root;
Trie();
TrieNode* getNode();
void insert(struct TrieNode* root, const std::string key);
bool search(struct TrieNode *root, std::string key);
bool isLastNode(struct TrieNode* root);
void suggestionsRec(struct TrieNode* root,std::string currPrefix);
int printAutoSuggestions(TrieNode* root, const std::string query);
};

Trie::Trie()
{
	root = getNode();
}

// Returns new trie node (initialized to NULLs)
struct TrieNode* Trie::getNode(void)
{
		return new TrieNode();
}

// If not present, inserts key into trie. If the
// key is prefix of trie node, just marks leaf node
void Trie::insert(struct TrieNode* root, const std::string key)
{
	TrieNode* node=root;
	for(int i=0;i<key.size();i++){
		if(node->children[key[i]-'a']==NULL)node->children[key[i]-'a']=getNode();
		node=node->children[key[i]-'a'];
	}
	node->isWordEnd=true;
}

bool Trie::search(struct TrieNode *root, std::string key)
{
	TrieNode* node=root;
	for(int i=0;i<key.size();i++){
		if(node->children[key[i]-'a']==NULL)return false;
		node=node->children[key[i]-'a'];
	}
	if(!node->isWordEnd)return false;
	return true;
}

// Returns 0 if current node has a child
// If all children are NULL, return 1.
bool Trie::isLastNode(struct TrieNode* root)
{
	bool flag=true;
	for(int i=0;i<26;i++){
		if(root->children[i]!=NULL){
			flag=false;
			break;
		}
	}
	return flag;
}

// Recursive function to print auto-suggestions for given
// node.
void Trie::suggestionsRec(struct TrieNode* root,std::string currPrefix)
{
	// found a std::string in Trie with the given prefix
	bool flag = false;

	TrieNode *A = root;
	int i = 0, n = 0;
	while(currPrefix[i] != 0) {
		n = CHAR_TO_INDEX(currPrefix[i]);
		if(A->children[n] == NULL){
			break;
		}
		A = A->children[n];
		i++;
	}

	std::string arr = currPrefix,arr_prime;
	if(A->isWordEnd == true){
		std::cout << arr << std::endl;
	}

	for(int i = 0; i < ALPHABET_SIZE; i++) {
		if(A->children[i] != NULL) flag = true;
	}
	if( flag == false) {
		return;
	}

	for(int i = 0; i < ALPHABET_SIZE; i++) {
		if(A->children[i] != NULL) {
			arr_prime = arr + char(i + (int)'a');
			suggestionsRec(root,arr_prime);
		}
	}

}

// print suggestions for given query prefix.
int Trie::printAutoSuggestions(TrieNode* root, const std::string query)
{
	if(root == NULL) return -1;

	int n1 = CHAR_TO_INDEX(query[0]);
	if(root->children[n1] == NULL) return 0;

	TrieNode *A = root;
	int i = 0, n = 0;
	while(query[i] != 0) {
		n = CHAR_TO_INDEX(query[i]);
		if(A->children[n] == NULL){
			break;
		}
		A = A->children[n];
		i++;
	}
	if(i != query.size()) return 0;

	suggestionsRec(root,query);
	return 1;
}
